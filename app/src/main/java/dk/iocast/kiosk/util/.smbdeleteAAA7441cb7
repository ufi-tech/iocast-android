package dk.iocast.kiosk.util

import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.net.wifi.WifiManager
import android.os.BatteryManager
import android.os.Build
import android.os.StatFs
import android.provider.Settings
import dk.iocast.kiosk.BuildConfig
import org.json.JSONObject
import java.io.File

/**
 * Collects device information for telemetry
 */
object DeviceInfo {

    fun collect(context: Context, currentUrl: String? = null): JSONObject {
        return JSONObject().apply {
            put("deviceId", IOCastApp.instance.prefs.deviceId)
            put("timestamp", System.currentTimeMillis() / 1000)

            // App info
            put("appVersion", BuildConfig.VERSION_NAME)
            put("appVersionCode", BuildConfig.VERSION_CODE)

            // Android info
            put("androidVersion", Build.VERSION.RELEASE)
            put("androidSdk", Build.VERSION.SDK_INT)
            put("manufacturer", Build.MANUFACTURER)
            put("model", Build.MODEL)
            put("device", Build.DEVICE)

            // Battery info
            val batteryInfo = getBatteryInfo(context)
            put("batteryLevel", batteryInfo.first)
            put("batteryCharging", batteryInfo.second)

            // Network info
            put("networkConnected", isNetworkConnected(context))
            put("wifiSsid", getWifiSsid(context))
            put("wifiSignal", getWifiSignalStrength(context))

            // Screen info
            put("screenOn", isScreenOn(context))

            // Memory info
            val memInfo = getMemoryInfo()
            put("memoryTotal", memInfo.first)
            put("memoryFree", memInfo.second)

            // Storage info
            val storageInfo = getStorageInfo()
            put("storageTotal", storageInfo.first)
            put("storageFree", storageInfo.second)

            // Current URL
            currentUrl?.let { put("currentUrl", it) }
        }
    }

    private fun getBatteryInfo(context: Context): Pair<Int, Boolean> {
        val batteryIntent = context.registerReceiver(
            null,
            IntentFilter(Intent.ACTION_BATTERY_CHANGED)
        )

        val level = batteryIntent?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1
        val scale = batteryIntent?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1
        val status = batteryIntent?.getIntExtra(BatteryManager.EXTRA_STATUS, -1) ?: -1

        val batteryPct = if (level >= 0 && scale > 0) (level * 100 / scale) else -1
        val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                status == BatteryManager.BATTERY_STATUS_FULL

        return Pair(batteryPct, isCharging)
    }

    private fun isNetworkConnected(context: Context): Boolean {
        val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = cm.activeNetwork ?: return false
        val capabilities = cm.getNetworkCapabilities(network) ?: return false
        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }

    private fun getWifiSsid(context: Context): String {
        return try {
            val wifiManager = context.applicationContext
                .getSystemService(Context.WIFI_SERVICE) as WifiManager
            val wifiInfo = wifiManager.connectionInfo
            wifiInfo.ssid?.replace("\"", "") ?: "unknown"
        } catch (e: Exception) {
            "unknown"
        }
    }

    private fun getWifiSignalStrength(context: Context): Int {
        return try {
            val wifiManager = context.applicationContext
                .getSystemService(Context.WIFI_SERVICE) as WifiManager
            wifiManager.connectionInfo.rssi
        } catch (e: Exception) {
            0
        }
    }

    private fun isScreenOn(context: Context): Boolean {
        return try {
            val powerManager = context.getSystemService(Context.POWER_SERVICE)
                    as android.os.PowerManager
            powerManager.isInteractive
        } catch (e: Exception) {
            true
        }
    }

    private fun getMemoryInfo(): Pair<Long, Long> {
        val runtime = Runtime.getRuntime()
        val total = runtime.maxMemory() / (1024 * 1024) // MB
        val free = (runtime.maxMemory() - runtime.totalMemory() + runtime.freeMemory()) / (1024 * 1024)
        return Pair(total, free)
    }

    private fun getStorageInfo(): Pair<Long, Long> {
        return try {
            val stat = StatFs(File("/data").path)
            val total = stat.blockCountLong * stat.blockSizeLong / (1024 * 1024) // MB
            val free = stat.availableBlocksLong * stat.blockSizeLong / (1024 * 1024)
            Pair(total, free)
        } catch (e: Exception) {
            Pair(0L, 0L)
        }
    }
}
