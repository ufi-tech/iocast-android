package dk.iocast.kiosk

import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.graphics.Bitmap
import android.os.Build
import android.os.Bundle
import android.view.KeyEvent
import android.view.View
import android.view.WindowInsets
import android.view.WindowInsetsController
import android.view.WindowManager
import android.webkit.WebChromeClient
import android.webkit.WebResourceError
import android.webkit.WebResourceRequest
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.ProgressBar
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.WindowCompat
import dk.iocast.kiosk.service.MqttService
import dk.iocast.kiosk.webview.JsInterface

/**
 * Main kiosk activity with fullscreen WebView
 */
class MainActivity : AppCompatActivity() {

    private lateinit var webView: WebView
    private lateinit var progressBar: ProgressBar

    private val commandReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            intent?.let { handleCommand(it) }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Check if setup is complete
        if (!IOCastApp.instance.prefs.isSetupComplete) {
            startActivity(Intent(this, SetupActivity::class.java))
            finish()
            return
        }

        setContentView(R.layout.activity_main)

        setupFullscreen()
        setupWebView()
        registerCommandReceiver()
        startMqttService()

        // Load the start URL
        loadUrl(IOCastApp.instance.prefs.currentUrl)
    }

    private fun setupFullscreen() {
        // Keep screen on
        if (IOCastApp.instance.prefs.keepScreenOn) {
            window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        }

        // Hide system UI
        WindowCompat.setDecorFitsSystemWindows(window, false)

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            window.insetsController?.let { controller ->
                controller.hide(WindowInsets.Type.systemBars())
                controller.systemBarsBehavior =
                    WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE
            }
        } else {
            @Suppress("DEPRECATION")
            window.decorView.systemUiVisibility = (
                View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                or View.SYSTEM_UI_FLAG_FULLSCREEN
                or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            )
        }
    }

    @SuppressLint("SetJavaScriptEnabled")
    private fun setupWebView() {
        webView = findViewById(R.id.webView)
        progressBar = findViewById(R.id.progressBar)

        webView.settings.apply {
            javaScriptEnabled = true
            domStorageEnabled = true
            databaseEnabled = true
            mediaPlaybackRequiresUserGesture = false
            mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
            cacheMode = WebSettings.LOAD_DEFAULT
            useWideViewPort = true
            loadWithOverviewMode = true
            builtInZoomControls = false
            displayZoomControls = false
            allowFileAccess = true
            allowContentAccess = true
        }

        // Add JavaScript interface
        webView.addJavascriptInterface(JsInterface(this), "iocast")

        webView.webViewClient = object : WebViewClient() {
            override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
                super.onPageStarted(view, url, favicon)
                progressBar.visibility = View.VISIBLE
            }

            override fun onPageFinished(view: WebView?, url: String?) {
                super.onPageFinished(view, url)
                progressBar.visibility = View.GONE
                url?.let { IOCastApp.instance.prefs.currentUrl = it }
            }

            override fun onReceivedError(
                view: WebView?,
                request: WebResourceRequest?,
                error: WebResourceError?
            ) {
                super.onReceivedError(view, request, error)
                if (request?.isForMainFrame == true) {
                    progressBar.visibility = View.GONE
                    // Could load offline page here
                }
            }
        }

        webView.webChromeClient = object : WebChromeClient() {
            override fun onProgressChanged(view: WebView?, newProgress: Int) {
                super.onProgressChanged(view, newProgress)
                progressBar.progress = newProgress
            }
        }
    }

    private fun registerCommandReceiver() {
        val filter = IntentFilter().apply {
            addAction("dk.iocast.kiosk.COMMAND")
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(commandReceiver, filter, RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(commandReceiver, filter)
        }
    }

    private fun startMqttService() {
        val serviceIntent = Intent(this, MqttService::class.java)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(serviceIntent)
        } else {
            startService(serviceIntent)
        }
    }

    private fun handleCommand(intent: Intent) {
        val command = intent.getStringExtra("command") ?: return
        val payload = intent.getStringExtra("payload")

        when (command) {
            "loadUrl" -> {
                payload?.let { loadUrl(it) }
            }
            "reload" -> {
                webView.reload()
            }
            "goBack" -> {
                if (webView.canGoBack()) webView.goBack()
            }
            "goForward" -> {
                if (webView.canGoForward()) webView.goForward()
            }
            "loadStartUrl" -> {
                loadUrl(IOCastApp.instance.prefs.startUrl)
            }
            "clearCache" -> {
                webView.clearCache(true)
                webView.reload()
            }
            "screenshot" -> {
                takeScreenshot()
            }
        }
    }

    fun loadUrl(url: String) {
        runOnUiThread {
            webView.loadUrl(url)
        }
    }

    fun reload() {
        runOnUiThread {
            webView.reload()
        }
    }

    fun getCurrentUrl(): String {
        return webView.url ?: IOCastApp.instance.prefs.startUrl
    }

    private fun takeScreenshot() {
        // Screenshot implementation - will be handled by MqttService
        sendBroadcast(Intent("dk.iocast.kiosk.SCREENSHOT_REQUEST"))
    }

    // Block back button in kiosk mode
    override fun onBackPressed() {
        if (IOCastApp.instance.prefs.kioskMode) {
            // In kiosk mode, go back in WebView history or do nothing
            if (webView.canGoBack()) {
                webView.goBack()
            }
            // Don't call super to prevent app exit
        } else {
            super.onBackPressed()
        }
    }

    // Block volume keys optionally
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        if (IOCastApp.instance.prefs.kioskMode) {
            when (keyCode) {
                KeyEvent.KEYCODE_HOME,
                KeyEvent.KEYCODE_APP_SWITCH -> return true
            }
        }
        return super.onKeyDown(keyCode, event)
    }

    override fun onResume() {
        super.onResume()
        setupFullscreen()
        webView.onResume()
    }

    override fun onPause() {
        super.onPause()
        webView.onPause()
    }

    override fun onDestroy() {
        super.onDestroy()
        try {
            unregisterReceiver(commandReceiver)
        } catch (e: Exception) {
            // Receiver not registered
        }
        webView.destroy()
    }
}
